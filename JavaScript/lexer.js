// This source code is generated by cs2js.

var Lexer = (function()
{
	Lexer.Operators = [
		".", "(", ")", "[", "]", "++", "--", "->",
		"+", "-", "!", "~", "&", "*", "/", "%",
		"<<", ">>", "<", ">", "<=", ">=", "==", "!=",
		"^", "|", "&&", "||", "??", "?:", "=",
		"+=", "-=", "*=", "/=", "%=", "&=", "|=",
		"^=", "<<=", ">>=", "=>", "?", ":" ];
	var dic = {}, keys = [];
	for (var i = 0; i < Lexer.Operators.length; i++)
	{
		var op = Lexer.Operators[i];
		if (dic[op[0]] != undefined)
			dic[op[0]].push(op);
		else
		{
			dic[op[0]] = [op];
			keys.push(op[0]);
		}
	}
	Lexer.OpHeads = keys.sort().join("");
	Lexer.OpDic = {};
	for (var i = 0; i < keys.length; i++)
	{
		var key = keys[i];
		var list = dic[key];
		list.sort(function(a, b)
		{
			if (a.length == b.length)
				return strcmp(a, b);
			else
				return b.length - a.length;
		});
		Lexer.OpDic[key] = list;
	}

	function Lexer(src)
	{
		this.src = src;
		this.pos = 0;
		this.clm = 1;
		this.lin = 1;
		if (src.length > 0)
			this.cur = src[0];
	}

	Lexer.prototype.MoveNext = function()
	{
		if (this.pos < this.src.length)
		{
			this.pos++;
			this.clm++;
			if (this.pos < this.src.length)
				this.cur = this.src[this.pos];
			else
				this.cur = "";
		}
		else
			this.cur = "";
	};

	Lexer.prototype.SetResult = function(t)
	{
		this.Token = this.src.substring(this.Position, this.pos);
		this.Type = t;
	};

	Lexer.prototype.ReadAllTokens = function()
	{
		var list = [];
		while (this.Read())
			list.push(new Token(this.Token, this.Type, this.Line, this.Column));
		return list;
	};

	Lexer.prototype.Read = function()
	{
		this.Column = this.clm;
		this.Line = this.lin;
		this.Position = this.pos;
		if (this.src == null || this.pos >= this.src.length)
		{
			this.Token = "";
			this.Type = TokenType.None;
			return false;
		}
		else
		{
			if (this.cur == " " || this.cur == "\t")
			{
				while (Lexer.IsSpace(this.cur))
					this.MoveNext();
				this.SetResult(TokenType.Space);
			}
			else if (this.cur == "\r")
			{
				this.MoveNext();
				if (this.cur == "\n")
					this.MoveNext();
				this.clm = 1;
				this.lin = this.lin + 1;
				this.SetResult(TokenType.NewLine);
			}
			else if (this.cur == "\n")
			{
				this.MoveNext();
				this.clm = 1;
				this.lin = this.lin + 1;
				this.Token = "\n";
				this.Type = TokenType.NewLine;
			}
			else if (this.cur == ";")
			{
				this.MoveNext();
				this.Token = ";";
				this.Type = TokenType.Separator;
			}
			else if (this.cur == "'")
				this.ReadChar();
			else if (this.cur == "\"")
				this.ReadString();
			else if (this.cur == "{")
			{
				this.MoveNext();
				this.Token = "{";
				this.Type = TokenType.BeginBlock;
			}
			else if (this.cur == "}")
			{
				this.MoveNext();
				this.Token = "}";
				this.Type = TokenType.EndBlock;
			}
			else if (this.cur == ",")
			{
				this.MoveNext();
				this.Token = ",";
				this.Type = TokenType.Comma;
			}
			else if (this.cur == "/" && this.IsBeginComment())
				this.ReadComment();
			else if (isnum(this.cur))
				this.ReadNumber();
			else if (Lexer.IsFirstLetter(this.cur))
			{
				while (Lexer.IsLetter(this.cur))
					this.MoveNext();
				this.Token = this.src.substring(this.Position, this.pos);
				this.Type = TokenType.Any;
			}
			else
			{
				var op = this.GetOperator();
				if (op != "")
				{
					this.pos = this.pos + op.length;
					this.clm = this.clm + op.length;
					if (this.pos < this.src.length)
						this.cur = this.src[this.pos];
					else
						this.cur = "";
					this.Token = op;
					this.Type = TokenType.Operator;
				}
				else
				{
					this.MoveNext();
					this.SetResult(TokenType.None);
					throw this.Abort("invalid character");
				}
			}
			return true;
		}
	};

	Lexer.IsSpace = function(ch)
	{
		return ch == " " || ch == "\t";
	};

	Lexer.IsFirstLetter = function(ch)
	{
		return ch == "_" ||
			("A" <= ch && ch <= "Z") ||
			("a" <= ch && ch <= "z");
	};

	Lexer.IsLetter = function(ch)
	{
		return Lexer.IsFirstLetter(ch) || isnum(ch);
	};

	Lexer.IsNewLine = function(ch)
	{
		return ch == "\r" || ch == "\n";
	};

	Lexer.prototype.IsBeginComment = function()
	{
		if (this.pos + 1 < this.src.length)
		{
			var ch = this.src[this.pos + 1];
			return this.cur == "/" && (ch == "/" || ch == "*");
		}
		else
			return false;
	};

	Lexer.prototype.IsEndComment = function()
	{
		if (this.pos + 1 < this.src.length)
			return this.cur == "*" && this.src[this.pos + 1] == "/";
		else
			return false;
	};

	Lexer.prototype.ReadComment = function()
	{
		this.MoveNext();
		if (this.cur == "/")
		{
			while (!(Lexer.IsNewLine(this.cur)))
				this.MoveNext();
			this.SetResult(TokenType.Comment1);
		}
		else
		{
			while (!(this.IsEndComment()))
				this.MoveNext();
			if (this.IsEndComment())
			{
				this.MoveNext();
				this.MoveNext();
				this.SetResult(TokenType.Comment);
			}
			else
				throw this.Abort("unterminated comment");
		}
	};

	Lexer.prototype.ReadString = function()
	{
		this.MoveNext();
		while (this.cur != "\"")
		{
			if (this.cur == "\\")
				this.MoveNext();
			this.MoveNext();
		}
		if (this.cur == "\"")
		{
			this.MoveNext();
			this.SetResult(TokenType.String);
		}
		else
			throw this.Abort("unterminated string");
	};

	Lexer.prototype.ReadChar = function()
	{
		this.MoveNext();
		if (this.cur == "\\")
			this.MoveNext();
		this.MoveNext();
		if (this.cur == "'")
		{
			this.MoveNext();
			this.SetResult(TokenType.Char);
		}
		else
			throw this.Abort("unterminated character");
	};

	Lexer.prototype.GetOperator = function()
	{
		if (Lexer.OpHeads.indexOf(this.cur) < 0)
			return "";
		else
		{
			var max = this.src.length - this.pos;
			var ret = "";
			var list = Lexer.OpDic[this.cur];
			for (var i = 0; i < list.length; i++)
			{
				op = list[i];
				if (ret == "" && op.length <= max && this.src.substr(this.pos, op.length) == op)
					ret = op;
			}
			return ret;
		}
	};

	Lexer.prototype.ReadNumber = function()
	{
		while (isnum(this.cur))
			this.MoveNext();
		if (this.cur == ".")
			this.ReadFloat();
		else
		{
			var ch2 = this.cur.toLowerCase();
			if (ch2 == "u")
			{
				this.MoveNext();
				if (this.cur.toLowerCase() == "l")
				{
					this.MoveNext();
					this.SetResult(TokenType.ULong);
				}
				else
				{
					this.SetResult(TokenType.UInt);
				}
			}
			else if (ch2 == "l")
			{
				this.MoveNext();
				this.SetResult(TokenType.Long);
			}
			else
				this.SetResult(TokenType.Int);
		}
	};

	Lexer.prototype.ReadFloat = function()
	{
		while (isnum(this.cur))
			this.MoveNext();
		var ch2 = this.cur.toLowerCase();
		if (ch2 == "f")
		{
			this.MoveNext();
			this.SetResult(TokenType.Float);
		}
		else if (ch2 == "d")
		{
			this.MoveNext();
			this.SetResult(TokenType.Double);
		}
		else
			this.SetResult(TokenType.Double);
	};

	Lexer.prototype.Abort = function(message)
	{
		return "[" + this.Line + "," + this.Column + "] " + message + ": " + this.Token;
	};

	return Lexer;
})();
