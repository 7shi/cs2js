// This source code is generated by cs2js.

var TypeName = (function()
{
	function TypeName(t, name)
	{
		this.Type = t;
		this.Name = name;
	}

	return TypeName;
})();

var Converter = (function()
{
	var spc = "    ";
	Converter.noop = [ "??", "?:", "?", ":" ];
	Converter.noop.Contains = function(s)
	{
		for (var i = 0; i < this.length; i++)
			if (s == this[i])
				return true;
		return false;
	};

	function Converter(tokens)
	{
		this.pos = 0;
		this.tokens = [];
		for (var i = 0; i < tokens.length; i++)
			if (!tokens[i].CanOmit())
				this.tokens.push(tokens[i]);
		this.last = new Token("", TokenType.None, 0, 0);
		if (this.tokens.length > 0)
			this.cur = this.tokens[0];
		else
			this.cur = this.last;
	}

	Converter.prototype.MoveNext = function()
	{
		if (this.pos < this.tokens.length)
		{
			this.pos = this.pos + 1;
			if (this.pos < this.tokens.length)
				this.cur = this.tokens[this.pos];
			else
				this.cur = this.last;
		}
		else
			this.cur = this.last;
	};

	Converter.prototype.Convert = function()
	{
		Debug.WriteLine("// This source code is generated by cs2js.");
		while (this.cur != this.last)
		{
			switch (this.cur.Text)
			{
			case "using":
				while (this.cur.Text != ";")
					this.MoveNext();
				this.MoveNext();
				break;
			case "namespace":
				this.ReadNamespace();
				break;
			default:
				this.ReadNamespaceInternal();
				break;
			}
		}
	};

	Converter.prototype.ReadUsing = function()
	{
		var sw = "";
		this.MoveNext();
		while (this.cur.Text != ";")
		{
			sw += this.cur.Text;
			this.MoveNext();
		}
		this.MoveNext();
		return sw;
	};

	Converter.prototype.ReadNamespace = function()
	{
		this.MoveNext();
		while (this.cur.Text != "{")
			this.MoveNext();
		this.MoveNext();
		while (this.cur != this.last && this.cur.Text != "}")
			this.ReadNamespaceInternal();
		this.MoveNext();
	};

	Converter.prototype.ReadNamespaceInternal = function()
	{
		var token = this.cur.Text;
		if (Converter.IsAccess(token))
		{
			this.MoveNext();
			this.ReadNamespaceInternal();
		}
		else if (token == "class" || token == "struct")
			this.ReadClass();
		else if (token == "enum")
			this.ReadEnum();
		else if (token == "abstract" || token == "partial")
			this.MoveNext();
		else
			throw this.Abort("not supported");
	};

	Converter.prototype.ReadEnum = function()
	{
		var dic = {};
		this.MoveNext();
		var name = this.cur.Text;
		this.MoveNext();
		Debug.WriteLine();
		Debug.WriteLine("var " + name + " =");
		if (this.cur.Text != "{")
			throw this.Abort("must be '{'");
		Debug.WriteLine("{");
		this.MoveNext();
		var v = 0;
		while (this.cur != this.last && this.cur.Text != "}")
		{
			var val = v.toString();
			var id = this.cur.Text;
			this.MoveNext();
			if (this.cur.Text == "=")
			{
				this.MoveNext();
				val = this.cur.Text;
				if (!isnum(val)) v = dic[val];
				this.MoveNext();
			}
			Debug.WriteLine(spc + id + ": " + val + ",");
			dic[id] = v;
			v++;
			if (this.cur.Text == ",")
				this.MoveNext();
		}
		this.MoveNext();
		Debug.WriteLine("};");
	};

	Converter.prototype.ReadClass = function()
	{
		this.isFirst = true;
		this.hasCtor = false;
		var t = this.cur.Text;
		this.MoveNext();
		this.cname = this.cur.Text;
		this.MoveNext();
		Debug.WriteLine();
		Debug.WriteLine("var " + this.cname + " = (function()");
		if (this.cur.Text == ":")
			throw this.Abort("can not inherit");
		if (this.cur.Text != "{")
			throw this.Abort("must be '{'");
		Debug.WriteLine("{");
		this.MoveNext();
		while (this.cur != this.last && this.cur.Text != "}")
			this.ReadMember(false, null);
		this.MoveNext();
		if (!this.isFirst)
			Debug.WriteLine();
		if (!this.hasCtor)
			Debug.WriteLine(spc + "function " + this.cname + "() {}");
		Debug.WriteLine(spc + "return " + this.cname + ";");
		Debug.WriteLine("})();");
	};

	Converter.prototype.ReadMember = function(isStatic, opt)
	{
		var token = this.cur.Text;
		if (token == "static")
		{
			this.MoveNext();
			this.ReadMember(true, opt);
		}
		else if (token == "abstract" || token == "virtual" || token == "override")
		{
			throw this.Abort("not supported");
		}
		else if (Converter.IsAccess(token))
		{
			this.MoveNext();
			this.ReadMember(isStatic, opt);
		}
		else
		{
			var tn = this.ReadDecl(false);
			switch (this.cur.Text)
			{
			case "(":
				this.ReadMethod(tn.Name, tn.Type, isStatic, opt);
				break;
			case "=":
			case ";":
				this.ReadField(tn.Name, tn.Type, isStatic);
				break;
			case "{":
				this.ReadProperty(tn.Name, tn.Type, isStatic, opt);
				break;
			default:
				throw this.Abort("syntax error");
			}
		}
	};

	Converter.prototype.ReadProperty = function(name, t, isStatic, opt)
	{
		this.MoveNext();
		while (this.cur.Text != "}")
		{
			if (Converter.IsAccess(this.cur.Text))
				this.MoveNext();
			if (this.cur.Text == "get" || this.cur.Text == "set")
			{
				var act = this.cur.Text;
				this.MoveNext();
				if (this.cur.Text != ";")
					throw this.Abort("must be auto property");
				this.MoveNext();
			}
			else
				throw this.Abort("syntax error");
		}
		this.MoveNext();
	};

	Converter.prototype.ReadField = function(name, t, isStatic)
	{
		var opt = this.cur.Text;
		this.MoveNext();
	};

	Converter.IsPrimitive = function(t)
	{
		return t == "bool" || t == "sbyte" || t == "byte" ||
			t == "char" || t == "short" || t == "ushort" ||
			t == "int" || t == "uint";
	};

	Converter.prototype.ReadMethod = function(name, t, isStatic, opt)
	{
		if (this.isFirst)
			this.isFirst = false;
		else
			Debug.WriteLine();
		Debug.Write(spc);
		stringappendix = "";
		if (t == null)
		{
			if (this.hasCtor)
				throw this.Abort("multiple constructor not supported");
			this.hasCtor = true;
			if (isStatic)
				throw this.Abort("static not supported");
			this.MoveNext();
			Debug.Write("function " + this.cname + "(");
			this.ReadArgs();
			Debug.WriteLine(")");
		}
		else
		{
			Debug.Write(this.cname + ".");
			if (!isStatic)
				Debug.Write("prototype.");
			Debug.Write(name + " = function(");
			this.MoveNext();
			this.ReadArgs();
			Debug.WriteLine(")");
			appendix = ";";
		}
		if (this.cur.Text != "{")
			throw this.Abort("block required");
		this.indent = spc;
		this.ReadBlock(appendix);
	};

	Converter.prototype.ReadArgs = function()
	{
		while (this.cur.Text != ")")
		{
			this.ReadArg();
			if (this.cur.Text == ",")
			{
				Debug.Write(", ");
				this.MoveNext();
			}
		}
		this.MoveNext();
	};

	Converter.prototype.ReadDecl = function(arg)
	{
		var list = [];
		var seps = "(){};=";
		if (arg)
			seps = seps + ",";
		while (this.cur.Text.length > 1 || seps.indexOf(this.cur.Text) < 0)
		{
			list.push(this.cur.Text);
			this.MoveNext();
		}
		if (list.length < 1)
			throw this.Abort("missing type or name");
		var name = list.pop();
		if (list.length > 0)
			return new TypeName(list.join(""), name);
		else
			return new TypeName(null, name);
	};

	Converter.prototype.ReadArg = function()
	{
		var tn = this.ReadDecl(true);
		if (tn.Type == null)
			throw this.Abort("missing type or name");
		Debug.Write(tn.Name);
	};

	Converter.prototype.ReadBlockOrSentence = function(appendix)
	{
		if (this.cur.Text == ";")
		{
			this.MoveNext();
			Debug.Write("()");
		}
		else if (this.cur.Text == "{")
			this.ReadBlock(appendix);
		else
		{
			var bak = this.indent;
			this.indent += spc;
			this.ReadSentence();
			this.indent = bak;
		}
	};

	Converter.prototype.ReadBlock = function(appendix)
	{
		if (this.cur.Text != "{")
			throw this.Abort("block required");
		var bak = this.indent;
		Debug.WriteLine(this.indent + "{");
		this.indent += spc;
		this.MoveNext();
		while (this.cur != this.last && this.cur.Text != "}")
			this.ReadSentence();
		this.MoveNext();
		this.indent = bak;
		Debug.WriteLine(this.indent + "}" + appendix);
	};

	Converter.prototype.ReadSentence = function()
	{
		switch (this.cur.Text)
		{
		case "return":
			Debug.Write(this.indent + "return");
			this.MoveNext();
			if (this.cur.Text == ";")
				this.MoveNext();
			else
			{
				Debug.Write(" ");
				this.ReadExpr(false);
			}
			Debug.WriteLine(";");
			break;
		case "if":
			this.ReadIf();
			break;
		case "while":
			this.ReadWhile();
			break;
		case "switch":
			this.ReadSwitch();
			break;
		case "for":
			this.ReadFor();
			break;
		case "foreach":
			this.ReadForEach();
			break;
		case "throw":
			this.MoveNext();
			Debug.Write(this.indent);
			Debug.Write("throw ");
			this.ReadExpr(false);
			Debug.WriteLine(";");
			break;
		case "var":
			this.ReadVar();
			break;
		default:
			Debug.Write(this.indent);
			this.ReadExpr(false);
			Debug.WriteLine(";");
			break;
		}
	};

	Converter.prototype.ReadExpr = function(array)
	{
		var seps = ");:";
		if (array)
		{
			seps = ",}";
			if (seps.indexOf(this.cur.Text) >= 0)
				throw this.Abort("element required");
		}
		while (this.cur.Text.length > 1 || seps.indexOf(this.cur.Text) < 0)
		{
			var t = this.cur.Text;
			if (t == "(")
			{
				this.isNew = false;
				this.MoveNext();
				Debug.Write("(");
				this.ReadExpr(false);
				Debug.Write(")");
			}
			else if (t == ",")
			{
				this.MoveNext();
				Debug.Write(", ");
			}
			else if (t == "new")
			{
				this.MoveNext();
				if (this.cur.Text == "[")
					this.ReadArray();
				else
				{
					Debug.Write("new ");
					this.isNew = true;
				}
			}
			else if (t == "delegate")
				this.ReadDelegate();
			else if (t == "int")
			{
				this.MoveNext();
				Debug.Write("int ");
			}
			else if (t == "is" || t == "as")
			{
				this.MoveNext();
				Debug.Write(" " + t + " ");
			}
			else if (t == "." || this.cur.Type != TokenType.Operator)
			{
				this.MoveNext();
				Debug.Write(t);
			}
			else if (t == "!")
			{
				this.MoveNext();
				Debug.Write("!");
			}
			else if (t == "~")
			{
				this.MoveNext();
				Debug.Write("~");
			}
			else if (Converter.noop.Contains(t))
				throw this.Abort("not supported");
			else if (this.isNew || t == "]")
			{
				this.MoveNext();
				Debug.Write(t);
			}
			else if (t == "[" || t == "++" || t == "--")
			{
				this.MoveNext();
				Debug.Write(t);
			}
			else
			{
				this.MoveNext();
				Debug.Write(" " + t + " ");
			}
		}
		if (!array)
			this.MoveNext();
	};

	Converter.prototype.ReadIf = function()
	{
		this.MoveNext();
		Debug.Write(this.indent);
		Debug.Write("if (");
		this.ReadIfInternal();
	};

	Converter.prototype.ReadIfInternal = function()
	{
		if (this.cur.Text != "(")
			throw this.Abort("must be '('");
		this.MoveNext();
		this.ReadExpr(false);
		Debug.WriteLine(")");
		this.ReadBlockOrSentence("");
		if (this.cur.Text == "else")
		{
			this.MoveNext();
			Debug.Write(this.indent);
			if (this.cur.Text == "if")
			{
				this.MoveNext();
				Debug.Write("else if (");
				this.ReadIfInternal();
			}
			else
			{
				Debug.WriteLine("else");
				this.ReadBlockOrSentence("");
			}
		}
	};

	Converter.prototype.ReadWhile = function()
	{
		this.MoveNext();
		Debug.Write(this.indent);
		Debug.Write("while (");
		if (this.cur.Text != "(")
			throw this.Abort("must be '('");
		this.MoveNext();
		this.ReadExpr(false);
		Debug.Write(")");
		if (this.cur.Text == ";")
		{
			this.MoveNext();
			Debug.WriteLine(";");
		}
		else
		{
			Debug.WriteLine();
			this.ReadBlockOrSentence("");
		}
	};

	Converter.prototype.ReadFor = function()
	{
		this.MoveNext();
		Debug.Write(this.indent);
		if (this.cur.Text != "(")
			throw this.Abort("must be '('");
		this.MoveNext();
		Debug.Write("for (");
		this.ReadExpr(false);
		Debug.Write("; ");
		this.ReadExpr(false);
		Debug.Write("; ");
		this.ReadExpr(false);
		Debug.WriteLine(")");
		this.ReadBlockOrSentence("");
	};

	Converter.prototype.ReadForEach = function()
	{
		this.MoveNext();
		Debug.Write(this.indent);
		if (this.cur.Text != "(")
			throw this.Abort("must be '('");
		this.MoveNext();
		if (this.cur.Text != "var")
			throw this.Abort("must be 'var'");
		this.MoveNext();
		Debug.Write("for (var " + this.cur.Text + " in ");
		this.MoveNext();
		if (this.cur.Text != "in")
			throw this.Abort("must be 'in'");
		this.MoveNext();
		this.ReadExpr(false);
		Debug.WriteLine(")");
		this.ReadBlockOrSentence("");
	};

	Converter.prototype.ReadSwitch = function()
	{
		this.MoveNext();
		Debug.Write(this.indent);
		Debug.Write("switch (");
		if (this.cur.Text != "(")
			throw this.Abort("must be '('");
		this.MoveNext();
		this.ReadExpr(false);
		Debug.WriteLine(")");
		Debug.Write(this.indent);
		Debug.WriteLine("{");
		if (this.cur.Text != "{")
			throw this.Abort("must be '{'");
		this.MoveNext();
		while (this.cur.Text != "}")
		{
			if (this.cur.Text == "case")
			{
				while (this.cur.Text == "case")
				{
					this.MoveNext();
					Debug.Write(this.indent);
					Debug.Write("case ");
					this.ReadExpr(false);
					Debug.WriteLine(":");
				}
				this.ReadCaseBlock();
			}
			else if (this.cur.Text == "default")
			{
				this.MoveNext();
				if (this.cur.Text != ":")
					throw this.Abort("must be ':'");
				Debug.Write(this.indent);
				Debug.WriteLine("default:");
				this.MoveNext();
				this.ReadCaseBlock();
			}
			else
				throw this.Abort("syntax error");
		}
		this.MoveNext();
		Debug.Write(this.indent);
		Debug.WriteLine("}");
	};

	Converter.prototype.ReadCaseBlock = function()
	{
		var bak = this.indent;
		this.indent += spc;
		while (this.cur.Text != "break" && this.cur.Text != "return" && this.cur.Text != "throw")
			this.ReadSentence();
		this.ReadSentence();
		this.indent = bak;
	};

	Converter.prototype.ReadVar = function()
	{
		this.MoveNext();
		if (this.cur.Type != TokenType.Any)
			throw this.Abort("name required");
		Debug.Write(this.indent);
		Debug.Write("var " + this.cur.Text + " = ");
		this.MoveNext();
		if (this.cur.Text != "=")
			throw this.Abort("must be '='");
		this.MoveNext();
		this.ReadExpr(false);
		Debug.WriteLine(";");
	};

	Converter.prototype.ReadDelegate = function()
	{
		this.MoveNext();
		if (this.cur.Text != "(")
			throw this.Abort("argument required");
		this.MoveNext();
		Debug.Write("function(");
		while (this.cur.Text != ")")
		{
			var tn = this.ReadDecl(true);
			Debug.Write(tn.Name);
			if (this.cur.Text == ",")
			{
				Debug.Write(", ");
				this.MoveNext();
			}
		}
		this.MoveNext();
		Debug.WriteLine(")");
		this.ReadBlock("");
		Debug.Write(this.indent);
	};

	Converter.prototype.ReadArray = function()
	{
		this.MoveNext();
		if (this.cur.Text != "]")
			throw this.Abort("must be ']'");
		this.MoveNext();
		if (this.cur.Text != "{")
			throw this.Abort("must be '{'");
		this.MoveNext();
		Debug.Write("[ ");
		while (this.cur.Text != "}")
		{
			this.ReadExpr(true);
			if (this.cur.Text == ",")
			{
				this.MoveNext();
				if (this.cur.Text != "}")
					Debug.Write(", ");
			}
		}
		this.MoveNext();
		Debug.Write(" ]");
	};

	Converter.prototype.Abort = function(message)
	{
		return "[" + this.cur.Line + "," + this.cur.Column + "] " +
			message + ": " + this.cur.Text;
	};

	Converter.IsAccess = function(s)
	{
		return s == "public" || s == "protected" || s == "private";
	};

	return Converter;
})();
