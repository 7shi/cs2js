<!DOCTYPE html>
<html>
<head></head>
<body>
<button id="button1">•ÏŠ·</button><br>
<textarea id="text1" cols="60" rows="40">enum Token { None, Symbol }

class Test1
{
	public void foo() { alert(Token.Symbol); }
}

class Test2
{
	public int a;

	public Test2(int a)
	{
		this.a = a;
	}

	public void foo()
	{
		alert(this.a);
	}
}
</textarea>
<textarea id="text2" cols="60" rows="40"></textarea>
<script type="text/javascript">
function strcmp(a, b)
{
	if (a > b) return 1;
	if (a < b) return -1;
	return 0;
}

function isnum(ch)
{
	return "0" <= ch && ch <= "9";
}

var NL = "\r\n";
</script>
<script type="text/javascript">
// from Token.cs
// This source code is generated by cs2js.

var TokenType =
{
	None: 0,
	Space: 1,
	NewLine: 2,
	Any: 3,
	Operator: 4,
	Separator: 5,
	Int: 6,
	UInt: 7,
	Long: 8,
	ULong: 9,
	Float: 10,
	Double: 11,
	String: 12,
	Char: 13,
	Comment: 14,
	Comment1: 15,
	BeginBlock: 16,
	EndBlock: 17,
	Comma: 18
};

var Token = (function()
{
	function Token(name, t, line, column)
	{
		this.Text = name;
		this.Type = t;
		this.Line = line;
		this.Column = column;
	}

	Token.prototype.Align = function(tab)
	{
		if (this.Type != TokenType.Space)
			return this.Text;
		else
		{
			sw = "";
			var column = this.Column;
			for (var i = 0; i < this.Text.length; i++)
			{
				ch = this.Text[i];
				if (ch == "\t")
				{
					var len = tab - ((column - 1) % tab);
					for (var i = 0; i < len; i++)
						sw += " ";
					column = column + len;
				}
				else
				{
					sw += ch;
					column = column + 1;
				}
			}
			return sw;
		}
	};

	Token.prototype.CanOmit = function()
	{
		return this.Type == TokenType.Space ||
			this.Type == TokenType.NewLine ||
			this.Type == TokenType.Comment ||
			this.Type == TokenType.Comment1;
	};

	Token.prototype.ToString = function()
	{
		tw = "[" + this.Line + ", " + this.Column + "] " + this.Type + ": ";
		switch (this.Type)
		{
		case TokenType.Space:
			tw += this.Align(4).length;
			break;
		case TokenType.NewLine:
			tw += this.Text.
				replace(/\r/g, "\\r").
				replace(/\n/g, "\\n");
			break;
		default:
			tw += this.Text;
			break;
		}
		return tw + NL;
	};

	return Token;
})();
</script>
<script type="text/javascript">
// from Lexer.cs
// This source code is generated by cs2js.

var Lexer = (function()
{
	Lexer.Operators = [
		".", "(", ")", "[", "]", "++", "--", "->",
		"+", "-", "!", "~", "&", "*", "/", "%",
		"<<", ">>", "<", ">", "<=", ">=", "==", "!=",
		"^", "|", "&&", "||", "??", "?:", "=",
		"+=", "-=", "*=", "/=", "%=", "&=", "|=",
		"^=", "<<=", ">>=", "=>", "?", ":" ];
	var dic = {}, keys = [];
	for (var i = 0; i < Lexer.Operators.length; i++)
	{
		var op = Lexer.Operators[i];
		if (dic[op[0]] != undefined)
			dic[op[0]].push(op);
		else
		{
			dic[op[0]] = [op];
			keys.push(op[0]);
		}
	}
	Lexer.OpHeads = keys.sort().join("");
	Lexer.OpDic = {};
	for (var i = 0; i < keys.length; i++)
	{
		var key = keys[i];
		var list = dic[key];
		list.sort(function(a, b)
		{
			if (a.length == b.length)
				return strcmp(a, b);
			else
				return b.length - a.length;
		});
		Lexer.OpDic[key] = list;
	}

	function Lexer(src)
	{
		this.src = src;
		this.pos = 0;
		this.clm = 1;
		this.lin = 1;
		if (src.length > 0)
			this.cur = src[0];
	}

	Lexer.prototype.MoveNext = function()
	{
		if (this.pos < this.src.length)
		{
			this.pos++;
			this.clm++;
			if (this.pos < this.src.length)
				this.cur = this.src[this.pos];
			else
				this.cur = "";
		}
		else
			this.cur = "";
	};

	Lexer.prototype.SetResult = function(t)
	{
		this.Token = this.src.substring(this.Position, this.pos);
		this.Type = t;
	};

	Lexer.prototype.ReadAllTokens = function()
	{
		var list = [];
		while (this.Read())
			list.push(new Token(this.Token, this.Type, this.Line, this.Column));
		return list;
	};

	Lexer.prototype.Read = function()
	{
		this.Column = this.clm;
		this.Line = this.lin;
		this.Position = this.pos;
		if (this.src == null || this.pos >= this.src.length)
		{
			this.Token = "";
			this.Type = TokenType.None;
			return false;
		}
		else
		{
			if (this.cur == " " || this.cur == "\t")
			{
				while (Lexer.IsSpace(this.cur))
					this.MoveNext();
				this.SetResult(TokenType.Space);
			}
			else if (this.cur == "\r")
			{
				this.MoveNext();
				if (this.cur == "\n")
					this.MoveNext();
				this.clm = 1;
				this.lin = this.lin + 1;
				this.SetResult(TokenType.NewLine);
			}
			else if (this.cur == "\n")
			{
				this.MoveNext();
				this.clm = 1;
				this.lin = this.lin + 1;
				this.Token = "\n";
				this.Type = TokenType.NewLine;
			}
			else if (this.cur == ";")
			{
				this.MoveNext();
				this.Token = ";";
				this.Type = TokenType.Separator;
			}
			else if (this.cur == "'")
				this.ReadChar();
			else if (this.cur == "\"")
				this.ReadString();
			else if (this.cur == "{")
			{
				this.MoveNext();
				this.Token = "{";
				this.Type = TokenType.BeginBlock;
			}
			else if (this.cur == "}")
			{
				this.MoveNext();
				this.Token = "}";
				this.Type = TokenType.EndBlock;
			}
			else if (this.cur == ",")
			{
				this.MoveNext();
				this.Token = ",";
				this.Type = TokenType.Comma;
			}
			else if (this.cur == "/" && this.IsBeginComment())
				this.ReadComment();
			else if (isnum(this.cur))
				this.ReadNumber();
			else if (Lexer.IsFirstLetter(this.cur))
			{
				while (Lexer.IsLetter(this.cur))
					this.MoveNext();
				this.Token = this.src.substring(this.Position, this.pos);
				this.Type = TokenType.Any;
			}
			else
			{
				var op = this.GetOperator();
				if (op != "")
				{
					this.pos = this.pos + op.length;
					this.clm = this.clm + op.length;
					if (this.pos < this.src.length)
						this.cur = this.src[this.pos];
					else
						this.cur = "";
					this.Token = op;
					this.Type = TokenType.Operator;
				}
				else
				{
					this.MoveNext();
					this.SetResult(TokenType.None);
					throw this.Abort("invalid character");
				}
			}
			return true;
		}
	};

	Lexer.IsSpace = function(ch)
	{
		return ch == " " || ch == "\t";
	};

	Lexer.IsFirstLetter = function(ch)
	{
		return ch == "_" ||
			("A" <= ch && ch <= "Z") ||
			("a" <= ch && ch <= "z");
	};

	Lexer.IsLetter = function(ch)
	{
		return Lexer.IsFirstLetter(ch) || isnum(ch);
	};

	Lexer.IsNewLine = function(ch)
	{
		return ch == "\r" || ch == "\n";
	};

	Lexer.prototype.IsBeginComment = function()
	{
		if (this.pos + 1 < this.src.length)
		{
			var ch = this.src[this.pos + 1];
			return this.cur == "/" && (ch == "/" || ch == "*");
		}
		else
			return false;
	};

	Lexer.prototype.IsEndComment = function()
	{
		if (this.pos + 1 < this.src.length)
			return this.cur == "*" && this.src[this.pos + 1] == "/";
		else
			return false;
	};

	Lexer.prototype.ReadComment = function()
	{
		this.MoveNext();
		if (this.cur == "/")
		{
			while (!(Lexer.IsNewLine(this.cur)))
				this.MoveNext();
			this.SetResult(TokenType.Comment1);
		}
		else
		{
			while (!(this.IsEndComment()))
				this.MoveNext();
			if (this.IsEndComment())
			{
				this.MoveNext();
				this.MoveNext();
				this.SetResult(TokenType.Comment);
			}
			else
				throw this.Abort("unterminated comment");
		}
	};

	Lexer.prototype.ReadString = function()
	{
		this.MoveNext();
		while (this.cur != "\"")
		{
			if (this.cur == "\\")
				this.MoveNext();
			this.MoveNext();
		}
		if (this.cur == "\"")
		{
			this.MoveNext();
			this.SetResult(TokenType.String);
		}
		else
			throw this.Abort("unterminated string");
	};

	Lexer.prototype.ReadChar = function()
	{
		this.MoveNext();
		if (this.cur == "\\")
			this.MoveNext();
		this.MoveNext();
		if (this.cur == "'")
		{
			this.MoveNext();
			this.SetResult(TokenType.Char);
		}
		else
			throw this.Abort("unterminated character");
	};

	Lexer.prototype.GetOperator = function()
	{
		if (Lexer.OpHeads.indexOf(this.cur) < 0)
			return "";
		else
		{
			var max = this.src.length - this.pos;
			var ret = "";
			var list = Lexer.OpDic[this.cur];
			for (var i = 0; i < list.length; i++)
			{
				op = list[i];
				if (ret == "" && op.length <= max && this.src.substr(this.pos, op.length) == op)
					ret = op;
			}
			return ret;
		}
	};

	Lexer.prototype.ReadNumber = function()
	{
		while (isnum(this.cur))
			this.MoveNext();
		if (this.cur == ".")
			this.ReadFloat();
		else
		{
			var ch2 = this.cur.toLowerCase();
			if (ch2 == "u")
			{
				this.MoveNext();
				if (this.cur.toLowerCase() == "l")
				{
					this.MoveNext();
					this.SetResult(TokenType.ULong);
				}
				else
				{
					this.SetResult(TokenType.UInt);
				}
			}
			else if (ch2 == "l")
			{
				this.MoveNext();
				this.SetResult(TokenType.Long);
			}
			else
				this.SetResult(TokenType.Int);
		}
	};

	Lexer.prototype.ReadFloat = function()
	{
		while (isnum(this.cur))
			this.MoveNext();
		var ch2 = this.cur.toLowerCase();
		if (ch2 == "f")
		{
			this.MoveNext();
			this.SetResult(TokenType.Float);
		}
		else if (ch2 == "d")
		{
			this.MoveNext();
			this.SetResult(TokenType.Double);
		}
		else
			this.SetResult(TokenType.Double);
	};

	Lexer.prototype.Abort = function(message)
	{
		return "[" + this.Line + "," + this.Column + "] " + message + ": " + this.Token;
	};

	return Lexer;
})();
</script>
<script type="text/javascript">
var button1 = document.getElementById("button1");
var text1 = document.getElementById("text1");
var text2 = document.getElementById("text2");
button1.onclick = function()
{
	var lexer = new Lexer(text1.value);
	try
	{
		var tokens = lexer.ReadAllTokens();
		var output = "";
		for (var i = 0; i < tokens.length; i++)
			output += tokens[i].ToString();
		text2.value = output;
	}
	catch (e)
	{
		text2.value = e;
	}
};
</script>
</body>
</html>
